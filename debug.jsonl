{"event": "span_start", "span": {"type": "program", "id": "0d3c448b-36a6-4cbc-b812-8fd96f998b05", "parent_id": null, "start_timestamp": "2025-04-08T14:23:20.590128Z", "end_timestamp": null, "attrs": {"main": "bs\\model.py", "active_profile": "default", "platform": "snowflake", "role": "ACCOUNTADMIN", "rai_app_name": "RELATIONALAI", "authenticator": "username_password_mfa", "ensure_change_tracking": true, "pyrel_program_id": "0d3c448b-36a6-4cbc-b812-8fd96f998b05"}}}
{"event": "span_start", "span": {"type": "auto_create_engine_async", "id": "11a19fb8-ef01-420d-8a8f-110da670a024", "parent_id": "0d3c448b-36a6-4cbc-b812-8fd96f998b05", "start_timestamp": "2025-04-08T14:23:20.864376Z", "end_timestamp": null, "attrs": {"active": null}}}
{"event": "span_end", "id": "11a19fb8-ef01-420d-8a8f-110da670a024", "end_timestamp": "2025-04-08T14:23:24.364166Z", "end_attrs": {}}
{"event": "span_start", "span": {"type": "rule_batch", "id": "f6a37458-72ef-46f9-bca2-eb0b75c1e6ad", "parent_id": "0d3c448b-36a6-4cbc-b812-8fd96f998b05", "start_timestamp": "2025-04-08T14:23:24.483809Z", "end_timestamp": null, "attrs": {}}}
{"event": "span_start", "span": {"type": "rule", "id": "040f4aea-ae63-4053-a5b6-f1ff66ef6bb4", "parent_id": "f6a37458-72ef-46f9-bca2-eb0b75c1e6ad", "start_timestamp": "2025-04-08T14:23:24.483809Z", "end_timestamp": null, "attrs": {"model": "BikeStore", "task": "sequence\n         call | RawCode(\"\\n@inline\\ndef make_identity(x..., z):\\n    exists((u) | rel_primitive_hash_tuple(x..., u) and\\n    hash_value_uint128_convert(u, z))\\n\\n@inline\\ndef pyrel_default({F}, c, k..., v):\\n    F(k..., v) or (not F(k..., _) and v = c)\\n\\n@inline\\ndef pyrel_unwrap(x in UInt128, y): y = x\\n\\n@inline\\ndef pyrel_dates_period_days(x in Date, y in Date, z in Int):\\n    exists((u) | dates_period_days(x, y , u) and u = ::std::common::^Day[z])\\n\\n@inline\\ndef pyrel_datetimes_period_milliseconds(x in DateTime, y in DateTime, z in Int):\\n    exists((u) | datetimes_period_milliseconds(x, y , u) and u = ^Millisecond[z])\\n\\n@inline\\ndef pyrel_bool_filter(a, b, {F}, z): { z = if_then_else[F(a, b), boolean_true, boolean_false] }\\n\\n@inline\\ndef pyrel_strftime(v, fmt, tz in String, s in String):\\n    (Date(v) and s = format_date[v, fmt])\\n    or (DateTime(v) and s = format_datetime[v, fmt, tz])\\n\\n@inline\\ndef pyrel_regex_match_all(pattern, string in String, pos in Int, offset in Int, match in String):\\n    regex_match_all(pattern, string, offset, match) and offset >= pos\\n\\n@inline\\ndef pyrel_regex_match(pattern, string in String, pos in Int, offset in Int, match in String):\\n    pyrel_regex_match_all(pattern, string, pos, offset, match) and offset = pos\\n\\n@inline\\ndef pyrel_regex_search(pattern, string in String, pos in Int, offset in Int, match in String):\\n    enumerate(pyrel_regex_match_all[pattern, string, pos], 1, offset, match)\\n\\n@inline\\ndef pyrel_regex_sub(pattern, repl in String, string in String, result in String):\\n    string_replace_multiple(string, {(last[regex_match_all[pattern, string]], repl)}, result)\\n\\n@inline\\ndef pyrel_capture_group(regex in Pattern, string in String, pos in Int, index, match in String):\\n    (Integer(index) and capture_group_by_index(regex, string, pos, index, match)) or\\n    (String(index) and capture_group_by_name(regex, string, pos, index, match))\\n\\ndeclare __resource\\ndeclare __compiled_patterns\\n\")\n", "name": "pyrel_base"}}}
{"event": "compilation", "timestamp": "2025-04-08T14:23:24.483809Z", "parent_id": "040f4aea-ae63-4053-a5b6-f1ff66ef6bb4", "source": {"file": "bs\\model.py", "line": 7, "block": "M = rai.Model(\"BikeStore\", ensure_change_tracking=True)", "task_id": 1279}, "task": "sequence\n         call | RawCode(\"\\n@inline\\ndef make_identity(x..., z):\\n    exists((u) | rel_primitive_hash_tuple(x..., u) and\\n    hash_value_uint128_convert(u, z))\\n\\n@inline\\ndef pyrel_default({F}, c, k..., v):\\n    F(k..., v) or (not F(k..., _) and v = c)\\n\\n@inline\\ndef pyrel_unwrap(x in UInt128, y): y = x\\n\\n@inline\\ndef pyrel_dates_period_days(x in Date, y in Date, z in Int):\\n    exists((u) | dates_period_days(x, y , u) and u = ::std::common::^Day[z])\\n\\n@inline\\ndef pyrel_datetimes_period_milliseconds(x in DateTime, y in DateTime, z in Int):\\n    exists((u) | datetimes_period_milliseconds(x, y , u) and u = ^Millisecond[z])\\n\\n@inline\\ndef pyrel_bool_filter(a, b, {F}, z): { z = if_then_else[F(a, b), boolean_true, boolean_false] }\\n\\n@inline\\ndef pyrel_strftime(v, fmt, tz in String, s in String):\\n    (Date(v) and s = format_date[v, fmt])\\n    or (DateTime(v) and s = format_datetime[v, fmt, tz])\\n\\n@inline\\ndef pyrel_regex_match_all(pattern, string in String, pos in Int, offset in Int, match in String):\\n    regex_match_all(pattern, string, offset, match) and offset >= pos\\n\\n@inline\\ndef pyrel_regex_match(pattern, string in String, pos in Int, offset in Int, match in String):\\n    pyrel_regex_match_all(pattern, string, pos, offset, match) and offset = pos\\n\\n@inline\\ndef pyrel_regex_search(pattern, string in String, pos in Int, offset in Int, match in String):\\n    enumerate(pyrel_regex_match_all[pattern, string, pos], 1, offset, match)\\n\\n@inline\\ndef pyrel_regex_sub(pattern, repl in String, string in String, result in String):\\n    string_replace_multiple(string, {(last[regex_match_all[pattern, string]], repl)}, result)\\n\\n@inline\\ndef pyrel_capture_group(regex in Pattern, string in String, pos in Int, index, match in String):\\n    (Integer(index) and capture_group_by_index(regex, string, pos, index, match)) or\\n    (String(index) and capture_group_by_name(regex, string, pos, index, match))\\n\\ndeclare __resource\\ndeclare __compiled_patterns\\n\")\n", "passes": [{"name": "Clone", "task": "sequence\n         call | RawCode(\"\\n@inline\\ndef make_identity(x..., z):\\n    exists((u) | rel_primitive_hash_tuple(x..., u) and\\n    hash_value_uint128_convert(u, z))\\n\\n@inline\\ndef pyrel_default({F}, c, k..., v):\\n    F(k..., v) or (not F(k..., _) and v = c)\\n\\n@inline\\ndef pyrel_unwrap(x in UInt128, y): y = x\\n\\n@inline\\ndef pyrel_dates_period_days(x in Date, y in Date, z in Int):\\n    exists((u) | dates_period_days(x, y , u) and u = ::std::common::^Day[z])\\n\\n@inline\\ndef pyrel_datetimes_period_milliseconds(x in DateTime, y in DateTime, z in Int):\\n    exists((u) | datetimes_period_milliseconds(x, y , u) and u = ^Millisecond[z])\\n\\n@inline\\ndef pyrel_bool_filter(a, b, {F}, z): { z = if_then_else[F(a, b), boolean_true, boolean_false] }\\n\\n@inline\\ndef pyrel_strftime(v, fmt, tz in String, s in String):\\n    (Date(v) and s = format_date[v, fmt])\\n    or (DateTime(v) and s = format_datetime[v, fmt, tz])\\n\\n@inline\\ndef pyrel_regex_match_all(pattern, string in String, pos in Int, offset in Int, match in String):\\n    regex_match_all(pattern, string, offset, match) and offset >= pos\\n\\n@inline\\ndef pyrel_regex_match(pattern, string in String, pos in Int, offset in Int, match in String):\\n    pyrel_regex_match_all(pattern, string, pos, offset, match) and offset = pos\\n\\n@inline\\ndef pyrel_regex_search(pattern, string in String, pos in Int, offset in Int, match in String):\\n    enumerate(pyrel_regex_match_all[pattern, string, pos], 1, offset, match)\\n\\n@inline\\ndef pyrel_regex_sub(pattern, repl in String, string in String, result in String):\\n    string_replace_multiple(string, {(last[regex_match_all[pattern, string]], repl)}, result)\\n\\n@inline\\ndef pyrel_capture_group(regex in Pattern, string in String, pos in Int, index, match in String):\\n    (Integer(index) and capture_group_by_index(regex, string, pos, index, match)) or\\n    (String(index) and capture_group_by_name(regex, string, pos, index, match))\\n\\ndeclare __resource\\ndeclare __compiled_patterns\\n\")\n", "elapsed": 9.14999982342124e-05}, {"name": "Shredder", "task": "sequence\n         call | RawCode(\"\\n@inline\\ndef make_identity(x..., z):\\n    exists((u) | rel_primitive_hash_tuple(x..., u) and\\n    hash_value_uint128_convert(u, z))\\n\\n@inline\\ndef pyrel_default({F}, c, k..., v):\\n    F(k..., v) or (not F(k..., _) and v = c)\\n\\n@inline\\ndef pyrel_unwrap(x in UInt128, y): y = x\\n\\n@inline\\ndef pyrel_dates_period_days(x in Date, y in Date, z in Int):\\n    exists((u) | dates_period_days(x, y , u) and u = ::std::common::^Day[z])\\n\\n@inline\\ndef pyrel_datetimes_period_milliseconds(x in DateTime, y in DateTime, z in Int):\\n    exists((u) | datetimes_period_milliseconds(x, y , u) and u = ^Millisecond[z])\\n\\n@inline\\ndef pyrel_bool_filter(a, b, {F}, z): { z = if_then_else[F(a, b), boolean_true, boolean_false] }\\n\\n@inline\\ndef pyrel_strftime(v, fmt, tz in String, s in String):\\n    (Date(v) and s = format_date[v, fmt])\\n    or (DateTime(v) and s = format_datetime[v, fmt, tz])\\n\\n@inline\\ndef pyrel_regex_match_all(pattern, string in String, pos in Int, offset in Int, match in String):\\n    regex_match_all(pattern, string, offset, match) and offset >= pos\\n\\n@inline\\ndef pyrel_regex_match(pattern, string in String, pos in Int, offset in Int, match in String):\\n    pyrel_regex_match_all(pattern, string, pos, offset, match) and offset = pos\\n\\n@inline\\ndef pyrel_regex_search(pattern, string in String, pos in Int, offset in Int, match in String):\\n    enumerate(pyrel_regex_match_all[pattern, string, pos], 1, offset, match)\\n\\n@inline\\ndef pyrel_regex_sub(pattern, repl in String, string in String, result in String):\\n    string_replace_multiple(string, {(last[regex_match_all[pattern, string]], repl)}, result)\\n\\n@inline\\ndef pyrel_capture_group(regex in Pattern, string in String, pos in Int, index, match in String):\\n    (Integer(index) and capture_group_by_index(regex, string, pos, index, match)) or\\n    (String(index) and capture_group_by_name(regex, string, pos, index, match))\\n\\ndeclare __resource\\ndeclare __compiled_patterns\\n\")\n", "elapsed": 2.9000002541579306e-05}, {"name": "Dataflow", "task": "sequence\n         call | RawCode(\"\\n@inline\\ndef make_identity(x..., z):\\n    exists((u) | rel_primitive_hash_tuple(x..., u) and\\n    hash_value_uint128_convert(u, z))\\n\\n@inline\\ndef pyrel_default({F}, c, k..., v):\\n    F(k..., v) or (not F(k..., _) and v = c)\\n\\n@inline\\ndef pyrel_unwrap(x in UInt128, y): y = x\\n\\n@inline\\ndef pyrel_dates_period_days(x in Date, y in Date, z in Int):\\n    exists((u) | dates_period_days(x, y , u) and u = ::std::common::^Day[z])\\n\\n@inline\\ndef pyrel_datetimes_period_milliseconds(x in DateTime, y in DateTime, z in Int):\\n    exists((u) | datetimes_period_milliseconds(x, y , u) and u = ^Millisecond[z])\\n\\n@inline\\ndef pyrel_bool_filter(a, b, {F}, z): { z = if_then_else[F(a, b), boolean_true, boolean_false] }\\n\\n@inline\\ndef pyrel_strftime(v, fmt, tz in String, s in String):\\n    (Date(v) and s = format_date[v, fmt])\\n    or (DateTime(v) and s = format_datetime[v, fmt, tz])\\n\\n@inline\\ndef pyrel_regex_match_all(pattern, string in String, pos in Int, offset in Int, match in String):\\n    regex_match_all(pattern, string, offset, match) and offset >= pos\\n\\n@inline\\ndef pyrel_regex_match(pattern, string in String, pos in Int, offset in Int, match in String):\\n    pyrel_regex_match_all(pattern, string, pos, offset, match) and offset = pos\\n\\n@inline\\ndef pyrel_regex_search(pattern, string in String, pos in Int, offset in Int, match in String):\\n    enumerate(pyrel_regex_match_all[pattern, string, pos], 1, offset, match)\\n\\n@inline\\ndef pyrel_regex_sub(pattern, repl in String, string in String, result in String):\\n    string_replace_multiple(string, {(last[regex_match_all[pattern, string]], repl)}, result)\\n\\n@inline\\ndef pyrel_capture_group(regex in Pattern, string in String, pos in Int, index, match in String):\\n    (Integer(index) and capture_group_by_index(regex, string, pos, index, match)) or\\n    (String(index) and capture_group_by_name(regex, string, pos, index, match))\\n\\ndeclare __resource\\ndeclare __compiled_patterns\\n\")\n", "elapsed": 2.9099988751113415e-05}, {"name": "Splinter", "task": "sequence\n         call | RawCode(\"\\n@inline\\ndef make_identity(x..., z):\\n    exists((u) | rel_primitive_hash_tuple(x..., u) and\\n    hash_value_uint128_convert(u, z))\\n\\n@inline\\ndef pyrel_default({F}, c, k..., v):\\n    F(k..., v) or (not F(k..., _) and v = c)\\n\\n@inline\\ndef pyrel_unwrap(x in UInt128, y): y = x\\n\\n@inline\\ndef pyrel_dates_period_days(x in Date, y in Date, z in Int):\\n    exists((u) | dates_period_days(x, y , u) and u = ::std::common::^Day[z])\\n\\n@inline\\ndef pyrel_datetimes_period_milliseconds(x in DateTime, y in DateTime, z in Int):\\n    exists((u) | datetimes_period_milliseconds(x, y , u) and u = ^Millisecond[z])\\n\\n@inline\\ndef pyrel_bool_filter(a, b, {F}, z): { z = if_then_else[F(a, b), boolean_true, boolean_false] }\\n\\n@inline\\ndef pyrel_strftime(v, fmt, tz in String, s in String):\\n    (Date(v) and s = format_date[v, fmt])\\n    or (DateTime(v) and s = format_datetime[v, fmt, tz])\\n\\n@inline\\ndef pyrel_regex_match_all(pattern, string in String, pos in Int, offset in Int, match in String):\\n    regex_match_all(pattern, string, offset, match) and offset >= pos\\n\\n@inline\\ndef pyrel_regex_match(pattern, string in String, pos in Int, offset in Int, match in String):\\n    pyrel_regex_match_all(pattern, string, pos, offset, match) and offset = pos\\n\\n@inline\\ndef pyrel_regex_search(pattern, string in String, pos in Int, offset in Int, match in String):\\n    enumerate(pyrel_regex_match_all[pattern, string, pos], 1, offset, match)\\n\\n@inline\\ndef pyrel_regex_sub(pattern, repl in String, string in String, result in String):\\n    string_replace_multiple(string, {(last[regex_match_all[pattern, string]], repl)}, result)\\n\\n@inline\\ndef pyrel_capture_group(regex in Pattern, string in String, pos in Int, index, match in String):\\n    (Integer(index) and capture_group_by_index(regex, string, pos, index, match)) or\\n    (String(index) and capture_group_by_name(regex, string, pos, index, match))\\n\\ndeclare __resource\\ndeclare __compiled_patterns\\n\")\n", "elapsed": 2.2599997464567423e-05}, {"name": "SetCollector", "task": "sequence\n         call | RawCode(\"\\n@inline\\ndef make_identity(x..., z):\\n    exists((u) | rel_primitive_hash_tuple(x..., u) and\\n    hash_value_uint128_convert(u, z))\\n\\n@inline\\ndef pyrel_default({F}, c, k..., v):\\n    F(k..., v) or (not F(k..., _) and v = c)\\n\\n@inline\\ndef pyrel_unwrap(x in UInt128, y): y = x\\n\\n@inline\\ndef pyrel_dates_period_days(x in Date, y in Date, z in Int):\\n    exists((u) | dates_period_days(x, y , u) and u = ::std::common::^Day[z])\\n\\n@inline\\ndef pyrel_datetimes_period_milliseconds(x in DateTime, y in DateTime, z in Int):\\n    exists((u) | datetimes_period_milliseconds(x, y , u) and u = ^Millisecond[z])\\n\\n@inline\\ndef pyrel_bool_filter(a, b, {F}, z): { z = if_then_else[F(a, b), boolean_true, boolean_false] }\\n\\n@inline\\ndef pyrel_strftime(v, fmt, tz in String, s in String):\\n    (Date(v) and s = format_date[v, fmt])\\n    or (DateTime(v) and s = format_datetime[v, fmt, tz])\\n\\n@inline\\ndef pyrel_regex_match_all(pattern, string in String, pos in Int, offset in Int, match in String):\\n    regex_match_all(pattern, string, offset, match) and offset >= pos\\n\\n@inline\\ndef pyrel_regex_match(pattern, string in String, pos in Int, offset in Int, match in String):\\n    pyrel_regex_match_all(pattern, string, pos, offset, match) and offset = pos\\n\\n@inline\\ndef pyrel_regex_search(pattern, string in String, pos in Int, offset in Int, match in String):\\n    enumerate(pyrel_regex_match_all[pattern, string, pos], 1, offset, match)\\n\\n@inline\\ndef pyrel_regex_sub(pattern, repl in String, string in String, result in String):\\n    string_replace_multiple(string, {(last[regex_match_all[pattern, string]], repl)}, result)\\n\\n@inline\\ndef pyrel_capture_group(regex in Pattern, string in String, pos in Int, index, match in String):\\n    (Integer(index) and capture_group_by_index(regex, string, pos, index, match)) or\\n    (String(index) and capture_group_by_name(regex, string, pos, index, match))\\n\\ndeclare __resource\\ndeclare __compiled_patterns\\n\")\n", "elapsed": 2.2799998987466097e-05}], "emitted": "\n@inline\ndef make_identity(x..., z):\n    exists((u) | rel_primitive_hash_tuple(x..., u) and\n    hash_value_uint128_convert(u, z))\n\n@inline\ndef pyrel_default({F}, c, k..., v):\n    F(k..., v) or (not F(k..., _) and v = c)\n\n@inline\ndef pyrel_unwrap(x in UInt128, y): y = x\n\n@inline\ndef pyrel_dates_period_days(x in Date, y in Date, z in Int):\n    exists((u) | dates_period_days(x, y , u) and u = ::std::common::^Day[z])\n\n@inline\ndef pyrel_datetimes_period_milliseconds(x in DateTime, y in DateTime, z in Int):\n    exists((u) | datetimes_period_milliseconds(x, y , u) and u = ^Millisecond[z])\n\n@inline\ndef pyrel_bool_filter(a, b, {F}, z): { z = if_then_else[F(a, b), boolean_true, boolean_false] }\n\n@inline\ndef pyrel_strftime(v, fmt, tz in String, s in String):\n    (Date(v) and s = format_date[v, fmt])\n    or (DateTime(v) and s = format_datetime[v, fmt, tz])\n\n@inline\ndef pyrel_regex_match_all(pattern, string in String, pos in Int, offset in Int, match in String):\n    regex_match_all(pattern, string, offset, match) and offset >= pos\n\n@inline\ndef pyrel_regex_match(pattern, string in String, pos in Int, offset in Int, match in String):\n    pyrel_regex_match_all(pattern, string, pos, offset, match) and offset = pos\n\n@inline\ndef pyrel_regex_search(pattern, string in String, pos in Int, offset in Int, match in String):\n    enumerate(pyrel_regex_match_all[pattern, string, pos], 1, offset, match)\n\n@inline\ndef pyrel_regex_sub(pattern, repl in String, string in String, result in String):\n    string_replace_multiple(string, {(last[regex_match_all[pattern, string]], repl)}, result)\n\n@inline\ndef pyrel_capture_group(regex in Pattern, string in String, pos in Int, index, match in String):\n    (Integer(index) and capture_group_by_index(regex, string, pos, index, match)) or\n    (String(index) and capture_group_by_name(regex, string, pos, index, match))\n\ndeclare __resource\ndeclare __compiled_patterns\n", "emit_time": 1.0899995686486363e-05}
{"event": "span_end", "id": "040f4aea-ae63-4053-a5b6-f1ff66ef6bb4", "end_timestamp": "2025-04-08T14:23:24.483809Z", "end_attrs": {}}
{"event": "error", "timestamp": "2025-04-08T14:23:25.056304Z", "parent_id": "f6a37458-72ef-46f9-bca2-eb0b75c1e6ad", "err": "(1304): 01bb8d9f-0204-e965-0047-d8070a7a028a: 002057 (42601): SQL compilation error:\nView definition for 'RELATIONALAI.API.DATA_STREAMS' declared 10 column(s), but view query produces 12 column(s).", "span_id": "f6a37458-72ef-46f9-bca2-eb0b75c1e6ad", "name": null, "message": "(1304): 01bb8d9f-0204-e965-0047-d8070a7a028a: 002057 (42601): SQL compilation error:\nView definition for 'RELATIONALAI.API.DATA_STREAMS' declared 10 column(s), but view query produces 12 column(s).", "content": null, "source": null, "raw_content": "(1304): 01bb8d9f-0204-e965-0047-d8070a7a028a: 002057 (42601): SQL compilation error:\nView definition for 'RELATIONALAI.API.DATA_STREAMS' declared 10 column(s), but view query produces 12 column(s)."}
